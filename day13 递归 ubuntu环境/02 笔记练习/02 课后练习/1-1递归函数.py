# ### 递归函数
# 递归函数:自己调用自己的函数,叫做递归函数
# 递:去
# 归:回
# 一去一回叫做递归

def digui(n):
	print(n,'------1')
	if n > 0:  #递归终止条件
		digui(n-1)
	print(n,'------2')

digui(3)

# 去的过程 (依次新建3个空间)
# n = 3 print(3,'-----1'),if 3 > 0: digui(3-1) => digui(2)
# 	代码阻塞在空间3的第12行
# n = 2 print(2,'-----1'),if 2 > 0: digui(2-1) => digui(1)
# 	代码阻塞在空间2的第12行
# n = 1 print(1,'-----1'),if 1 > 0: digui(1-1) => digui(0)
# 	代码阻塞在空间1的第12行
# n = 0 print(0,'-----1'),if 0 > 0: 不成立 print(0,'------2')
# 	代码在空间0执行完毕
# 	到此最后一层函数空间(空间0)彻底执行完毕,空间0占用的内存释放
#
# 回的过程 (依次释放3个空间)
# 回到上一层函数空间(空间1) n=1 代码在第12行的位置,继续往下执行
# 	print(1,'------2')
# 	原因:空间1中的第13行,之前去的过程,并没有执行,现在回的过程,
# 		  需要接着12行的断点,往下执行第13行,从而释放空间1占用的内存
#
# 回到上一层函数空间(空间2) n=2 代码在第12行的位置,继续往下执行
# 	print(2,'------2')
#
# 回到上一层函数空间(空间3) n=3 代码在第12行的位置,继续往下执行
# 	print(3,'------2')

# 到此递归函数执行结束
# 打印3210123
#
# 每次调用函数时,都要单独在内存中新开辟空间,叫做栈帧空间,用来运行函数中的代码
#
# 递归总结:
# 1 递归实际上是不停的新开辟栈帧空间和释放栈帧空间的过程.
# 	开辟就是去的过程,释放就是会的过程
# 2 递归什么时候触发归的过程
# 	1.当最后一层栈帧空间执行结束的时候,触发归的过程.
# 	2.当遇到return返回值的时候终止当前函数,触发归的过程.
# 3 递归不能无限的去新开辟空间,可能造成内存溢出,蓝屏死机的过程.
# 	所以一定要给予跳出的条件(如果递归的层数太大,不推荐使用)
# 4 新开辟的一个个栈帧空间,数据是彼此独立不共享的

# 递归不能无限开辟空间
# 官网的说法最大默认是1000层

# def deepfunc():
	# deepfunc()
## deepfunc()




































