一、网络编程
1 黏包
2 服务端合法性校验
3 tcp登录

二、并发编程
1 多进程  
  00 多线程基础
	1 隔离  异步
	2 join 同步子父进程
	3 deamon  守护
	  监控报活
	  
  01 进程锁   同步
	  lock   单个进程锁
		抢票
	  semaphore   同时多个进程锁
  
  02 进程事件
	  Event  红绿灯
		 全国：红绿灯一直在运行
		 包头：没有车的时候,把红绿灯关了  daemon（守护进程）
  
  03 进程队列
	  Queue  进程队列
	  队列用于进程间的通讯  ipc
	  
	  自定义进程
	  1继承Process类
	  2重新run方法
	  3手动调用父类的构造方法 super()
  
  04  生产者消费者
	  生产者消费者模型
		# 1.基础版生产者消费者模型
		# """问题 : 当前模型,程序不能正常终止--有阻塞  消费者子进程一直在运行  """
		
		# 2.优化模型
		# """特点 : 手动在队列的最后,加入标识None, 终止消费者模型"""
		
		 3.多个生产者和消费者
		# """ 问题 : 虽然可以解决问题 , 但是需要加入多个None  , 代码冗余"""
	  
	  joinablequeue
  
  05 Manager
	 进程间共享数据
	 1 共享字典
	 2 共享列表
	 
2 多线程
	01 线程基础
		(1) 一个进程里包含了多个线程,线程之间是异步并发
		(2) 并发的多进程和多线程之间,多线程的速度更快
		(3) 多线程之间,数据共享
		
	02 自定义线程
	  1继承Thread类
	  2重新run方法
	  3手动调用父类的构造方法 super()
	  
	  线程中的相关属性
	  
	03 守护线程
		守护线程 : 等待所有线程全部执行完毕之后,自己再终止程序,守护所有线程
		和守护进程不同,守护进程守护的是主进程
		
		设置守护线程 (启动前设置)
		t.setDaemon(True)
		
		设置守护进程 (启动前设置)
		t.daemon = True
		
	04 线程锁(数据安全，数据准确) 和进程锁写法类似
		01 单个线程锁
			with语法可以简化上锁+解锁的操作,自动完成
			with lock:  #和with open类似
			lock.acquire()
			lock.release()
		02 同时多个线程锁
			semaphore：同一时间对多个线程上多把锁
		03  (1) 语法上的死锁：是连续上锁不解锁
			(2) 逻辑上的死锁
			(3) 使用递归锁-解锁RLock
				# 递归锁的提出专门用来解决死锁现象
				# 用于快速解决线上项目死锁问题
				# 即使连续上锁,使用递归锁后也可以解锁,因为递归锁的作用在于解锁;
					# noodles_lock = Lock()
					# kuaizi_lock = Lock()
					# 让noodles_lock和kuaizi_lock 都等于递归锁
					# noodles_lock = kuaizi_lock = RLock()
			(4) 尽量使用一把锁解决问题,(少用锁嵌套-2个锁,容易逻辑死锁)
		
	05 线程事件 Event
		# wait   : 动态加阻塞 (True => 放行  False => 阻塞)
		# is_set : 获取内部成员属性值是True 还是 False(默认是False)
		# set    : 把False -> True
		# clear  : 把True  -> False
		模拟连接远程数据库
		
	06 线程队列
		# put 存放 超出队列长度阻塞
		# get 获取 超出队列长度阻塞
		# put_nowait 存放,超出队列长度报错
		# get_nowait 获取,超出队列长度报错
		
		# (1) Queue 
			先进先出,后进后出
		
		# (2) LifoQueue 
			先进后出,后进先出(栈的特点)
		
		# (3) PriorityQueue
			按照优先级顺序进行排序存放(默认从小到大)
			在一个优先级队列中,要放同一类型的数据,不能混合使用
		
3 进程池和线程池
	01 进程池
		多条进程提前开辟,可触发多cpu的并行效果
		
		(1) 创建进程池对象
			默认参数是 系统最大的逻辑核心数
		(2) 异步提交任务
			submit(任务,参数1,参数2 ... )
		(3) 获取当前任务的返回值
			result()
		(4) shutdown 等待所有进程池里的进程执行完毕之后,再放行
	
	02 线程池
		(1) 创建线程池对象
			默认参数是 系统最大的逻辑核心数*5
		(2) 异步提交任务
			submit(任务,参数1,参数2 ... )
		(3) 获取当前任务的返回值
			result()
		(4) shutdown 等待所有线程池里的线程执行完毕之后,再放行
	
	03 线程池 map
		t = ThreadPoolExecutor()
		it = t.map(func,range(100)) #参数1：函数名  参数2：可迭代对象
		# 返回的数据是迭代器
	
	
	总结: 无论是进程池还是线程池,都是由固定的进程数或者线程数来执行所有任务
	系统不会额外创建多余的进程或者线程来执行任务;
	
	04 回调函数
		回调函数: 回头调用一下函数获取最后结果
		
		# 在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。
		# 可以这么理解，在传入一个回调函数之前，中间函数是不完整的。
		# 换句话说，程序可以在运行时，通过登记不同的回调函数，
		# 来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了
		
		# 回调函数:  把函数名字当做参数传递,然后,函数名(),就在调用函数
		# 起始函数(主函数):中间函数的调用者,把回调函数的函数名call_back作为实参
		# 回调函数的作用:扩展和修改中间函数(回调函数的调用者)的功能

		# 闭包和装饰器:把函数名字当做返回值,然后,函数名(),就在调用函数
		# 装饰器的作用:扩展原函数的功能
		
		进程池的回调函数由主进程执行--异步
		线程池的回调函数由子线程执行
		
		使用add_done_callback在获取最后返回值的时候,可以异步并行
		# 直接使用result获取返回值的时候,会变成同步程序,速度慢;
		
		# 原型:
		class Ceshi():
			def add_done_callback(self,func): #2中间函数(库函数) 回调函数的调用者
				print("系统执行操作1 ... ")
				print("系统执行操作2 ... ")
				# 回头调用一下  调用回调函数  扩展和修改中间函数的功能
				func(self)	
				
			def result(self):
				return 112233	
				
		def call_back(obj):   #1回调函数(应用) 形参是对象
			print(obj.result()) #修改这里,就能扩展和修改中间函数的功能

		obj = Ceshi()
		obj.add_done_callback(call_back)  #3起始函数(主函数):中间函数的调用者
		# 对象调成员方法的时候,把回调函数的函数名call_back作为实参
	
4 协程
	# 进程是资源分配的最小单位
	# 线程是程序调度的最小单位
	# 协程是线程实现的具体方式

	# 总结:
	# 在进程一定的情况下,开辟多个线程,
	# 在线程一定的情况下,创建多个协程,
	# 以便提高更大的并行并发
	
	(1) 用协程改写生产者消费者模型
	(2) greenlet 协程的早期版本
		switch 可以切换任务,但是需要手动切换
	(3) 升级到gevent版本
		自动进行任务上的切换,但是不能识别阻塞
	(4) 协程的终极版本;
		引入猴子补丁,可以实现所有的阻塞全部识别
		
	# (1) spawn(函数,参数1,参数2,参数 .... ) 启动协程
	# (2) join 阻塞,直到某个协程在任务执行完毕之后在放行
	# (3) joinall 等待所有协程任务执行完毕之后放行;
	# 	  # g1.join()  g2.join() <=> gevent.joinall( [g1,g2..] )
	# (4) value 获取协程任务中的返回值 g1.value  g2.value   
		
	利用协程爬取数据
	
三、面向对象
1 封装
	00 类的概念
		(1)类的定义
		(2)类的实例化
		(3)类的基本结构
		(4)类的命名
			推荐大驼峰命名法 MyCar
		
	01 对象的操作
		# 封装:
			# 1.私有 : 在类内可以互相访问,在类外不能访问
			# 2.公有 : 在类内或者类外都可以访问

		# 类中成员:
			# 1.成员属性
			# 2.成员方法
			
		# 绑定方法:
			# 1.绑定到对象 : 当对象去调用类中成员方法时,系统会默认把该对象当成参数传递给该方法 self
			# 2.绑定到类   : 当对象或者类去调用类中成员方法时,系统会默认把该类当成参数传递给该方法  @classmethod  cls

		# 使用方式:
			# 对象.成员属性
			# 对象.成员方法
			
		__dict__ 获取类对象的内部成员
		print(obj.__dict__)
		print(MyCar.__dict__)
		
		对象动态添加公有成员属性
		对象动态添加公有成员方法	
	
	02 类的操作
		# 对比 对象和类之间的不同
		# 1.类中的无参方法默认只能类来调用,对象无法调取
		# 2.对象可以调用类中的成员,反过来,类不能调用对象中的成员
		# 3.每创建一个对象都会在内存中占用一份空间,对象之间是彼此独立的;
		类和对象是两个独立的内存空间
		
		类动态添加公有成员属性
		类动态添加公有成员方法
		
	03 私有成员和成员删除
		使用类中的公有方法,间接访问私有成员
		
		# 1.对象可以访问类中的公有成员,但是无权修改或者删除该类中的成员
		# 2.对象在访问成员时,优先访问该对象自己的成员,如果没有再访问类的,类如果也没有直接报错;
			类和对象是两个独立的内存空间
			
		# 注意: 对象无法调无参方法!! 
		# 返回来,类可以调用对象的绑定方法么? 可以!!  #把对象当做实参传递即可

2 继承
	01 单继承
		# 一个类除了自身所拥有的属性方法之外,还获取了另外一个类的成员属性和方法 是一种继承关系
		# 被继承的类叫做父类(基类,超类),继承的类叫做子类(衍生类)
		# 在python中所有类都继承object这个父类
		# 继承: (1) 单继承  (2) 多继承
		
		子类可以调用父类的公有成员
		子类不能调用父类的私有成员
		子类可以重写父类的同名公有方法
	
	02 多继承
		class Daughter(Father,Mother):
			pass
	
	
	03 菱形继承
	04 构造方法
			# 触发时机：实例化对象,初始化的时候触发
			# 功能：为对象添加成员（属性或方法）
			# 参数：参数不固定,至少一个self参数
			# 返回值：无
	

3 多态
4 魔术方法 异常
5 装饰器
6 反射

















